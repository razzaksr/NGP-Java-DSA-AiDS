Objective of programming:
	Data
	Operations/ functions:
		Create
		Read 
		Update
		Delete


Java Programming:
	Desktop
	Web
	Mobile
	
System Design Engineer
	Low level designer:
		design architecture, algorithms, design patterns, ...


Syntax:
class IDENTIFIER{
	public static void main(String[] identifier){
	.....
	}
}	


Java Development Kit >> Software DK
	build(.java) compile >> source code >> byte code(ASCII+UNI)>> .class
	Java Runtime Environment: in built classes grouped in packages
		Execute
		Java Virtual Machine:
			byte code to machine code
			
Compile: source to bytecode
	javac Filename.java
Execute:	bytecode to machine
	java Classname
	


https://github.com/razzaksr/NGP-Java-DSA-AiDS


Scanner >> java.util
	Scanner obj = new Scanner(System.in); >> object
		nextInt	>> get int input from keyboard
		nextFloat
		nextDouble
		nextShort
		nextLong
		nextBoolean
		nextByte
	String:	
		next		>> word
		nextLine	>> sentence




Class has following members:
	data member>> objects/ variables 				
	member functions/ methods


Object Oriented Programming:
	Build the application with Security, Reusability

	Class
	Encapsulation:
		private data
		public function to access the private data

	Constructor:
		method/ function to be executed while creating an object
		it has priority execution over the other functions
		members initialization
		name of the constructor same as class name
	Polymorphism:
		Overloading: within class same block to be created multiple times by changing parameters type, order, count 
			constructor
			function
		Overriding: between two classes which involved in inheritance, which maintain same name, parameter

	Inheritance: Enables Object reusability between classes
		base/ super/ parent 
		derived / child 

		DerivedClass extends BaseClass

	Abstraction:
		interface like a class block:
			members>> data members, member functions

			class extends class
			class implements interface
			interface extends interface
			interface cannot inherit class


	





task:
employee
1. check which TAX slab
2. check eligibility of PL by check last 3/5 years ITR filed or not

Upcasting & down casting

Sealed and final

Object Cloning:
	1. implements Cloneable
	2. override clone in derived class


Wrapper classes: java.lang
int(4) >> Integer
float(4)>> Float
double(8)>> Double
char(2)>> Character
boolean(1nibble/4bit)>> Boolean
long(8)>> Long
short(2)>> Short
byte(1)>> Byte


task:
	Abstract Class PRODUCTS contains array consists product cost such as 900,4500,200,1600 
	methods:
	1. Non abstract method: findBoundary(min, max) >> Now finding existing costs which matches user given boundary like min and max inside same class
	2. Abstract method: findAll>> print all costs


	interface SHORTLIST contains
	1.Abstract method: findMax()>> Find max cost in that array, consider this method as abstract inside interface

	Inherit All in the class APP 


Specifiers and Modifiers:

			class 			data member			member function

public 		all over project		based on class scope	based on class scope
private		member class		within class			within class
static		member class		calling via classname	calling via classname
final			cannot inherit		constant				cannot override
default		package level		package level			package level
protected		member class		accessible via inheritance
							while out of package
abstract		cannot instantiate	NA					need to override



Exception Handling:
	Error			>> compile time errors: syntax error, Case error	>> can be fixed
				     run time errors: cannot be fixed
	Exception		>> due to uncertain condition the code will be terminated abnormally
					compile time/ checked >> need to handle at compile time in order to 						execute
					usually raised when some of in built method are called/used by 						developers
				     run time/ unchecked	>> raised due to user mistakes

	Objective to handle the exception:
		1. let the user to complete the process even though they make mistake
		2. provide another chance

	Handling:
		1. try{
			.. possible lines which cause exception
		}catch(ExceptionClass obj){
			// handling
		}

		2. throws


		Throwable		>> interface
			|
		Exception			class>> java.lang
			|
		RuntimeException	class>> java.lang
			|
		NullPointerException	class>> java.lang


Type parsing:
	Convert String into Other types via its wrapper class
		WrapperClass.parseType(string)
	eg: converting string into int
		Integer.parseInt(string)
		String hi="78"; String hello="89!"
	NumberFormatException
	

	ExceptionChain
	NestedException
	single try multi catch
	infinite and finite amount of chances
	exception forwarding via throw keyword
	Custom exception creation>> eg: invalid aadhaar when its not equal to the length of 12


Loop:
Nested loop in real time scenario>> ticket booking for multiple busses, giant wheel
Patterns:
	square
	left upper floyd/triangle
	right upper floyd/triangle
	upper pyramid
	sand clock

	Generics:
		class, method, interface, object
		eg: CRUD Operations


Collection framework: java.util
	Iterable	>> interface
	|
	Collections>>
	|
	Collection
	|
	List, Set, Map


List: duplicates allowed, positions available
ArrayList, Vector, LinkedList, Stack
Collections >> sort, replaceAll, reverse
Comparator
	
Queue: PriorityQueue, Deque

Set: No duplicates, no position
HashSet
TreeSet 
LinkedHashSet

Comparable

Map: <KeyClass,ValueClass>, where Key Objects must be duplicated, values can be

HashMap, TreeMap, Hashtable





Drawbacks of array:
	No inbuilt methods
	fixed size
	fixed type
	compile time
	not secure





Data structures:
	how can we arrange data in the storage
		eg: lab system were arranged as multi dimensional array
	
Analysis:
Time >> how fast the required action to be done, it s purely based on algorithm
Space >> how much space(variables, constants) required to complete a process

Notations:
	Omega	>> low/ min 
	Theta	>> Average 
	Oho		>> worst/ max 

O(1)		one
O(n)		linear
O(logn)	divide
O(n2)	nested
O(nlogn)	eg: merge, binary search


Task:
Consider the array contains salary of my employees size 10 where you are required to search and display the second high salaried employee's position
eg:
8.9, 4.5, 1.8, 2.5, 4.1, 5.0, 3.5, 2.8, 15.6, 2.1
Output:
0
9.2,8.9,5.2,3.5,1.55, 19.5, 1.8, 7.5, 21.5, 10.5
Output:
5


An array contains invoices of the day, your task is find missing least invoice
eg:
invoices = [45,91,90,92,46]
output:47
invoices = [1,2,3,4,5]
Output: 6
invoices = [12,13,14,16,17]
Output: 15



Merge sort:

Divide and Conquer




Sort Colors (Dutch National Flag)
	Problem Statement:
		Assume that your are part of support team in IRCTC app where customers would raise issue and it will be considered priority ticket such as 0, 1 and 2. now today tickets are in the bucket and you need to arrange it by priority
		Example:
		Input:
		2,0,0,1,0,2,0,1
		Output:
		0,0,0,0,1,1,2,2
		Sample Input:
		nums = [2, 0, 2, 1, 1, 0]
		Expected Output:
		[0, 0, 1, 1, 2, 2]



Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
Constraints:
s consists of parentheses only '()[]{}'.
Example 1:
Input: s = "()"
Output: true
Example 2:
Input: s = "()[]{}"
Output: true
Example 3:
Input: s = "(]"
Output: false
Example 4:
Input: s = "([])"
Output: true
Example 5:
Input: s = "([)]"
Output: false



Given an array of integers nums, for each element in the array, find the Next Greater Element (NGE) to its right.
- The Next Greater Element for an element x is the first element to the right of x that is strictly greater than x.
- If no such element exists, return -1 for that position.
You need to return a list of integers where each index contains the Next Greater Element of the corresponding element in nums.
Example Explanation
For nums = [2, 1, 3]:
- Next greater for 2 → 3
- Next greater for 1 → 3
- Next greater for 3 → -1
Output: [3, 3, -1]
Input1: nums = [4, 5, 2, 25]
Output: [5, 25, 25, -1]
Input: nums = [13, 7, 6, 12]
Output: [-1, 12, 12, -1]




Quick sort:
divide and conquer 
divide by pivotal point :: pivotal data always end of array


Implement Stack structure with its operations using linkedlist(object oriented way)

1. Node (value, address/reference to next node)
2. Service>> stack operations implementations
3. Remote>> stack operations declaration
	push
	pop
	isEmpty
	peek

largest rectangle are in histogram
arr= [2,3,4,5,2,3]
        0 1 2 3 4 5

index=0, cvalue=2
stack>> 0
index=1, cvalue=3
stack>> 0, 1
index=2, cvalue=4
stack>> 0, 1, 2
index=3, cvalue=5
stack>> 0,1,2,3,
index=4, cvalue=2

pop when cvalue < top's value
1. pop>>3, arr[3] >> 5 >> height
stack >> 0, 1, 2
width >> index - 2 - 1 >> 1 
width*height>>5*1>> 5>> area
2. since, cvalue=2 < arr[2]=4,
pop>>2,arr[2] >> 4 >> height
stack>>0,1
width>> 4-1-1>> 2
w*h>>2*4>> 8>> area
3. since cvalue=2 < arr[1]=3
pop>>1, arr[1]>> 3>> h
stack>>0
w>>4-0-1>>3
w*h>>3*3>>9>> area

push index 4 since 2==2
stack>>0,4

index=5, cvalue=3
stack>> 0,4,5

index=6, cvalue=0
pop>>5, arr[5]=3>>h
stack>> 0,4
w= 6-4-1>> 1
w*h>>1*3>> 3>> area

pop>>4, arr[4]=2>>h
stack>> 0
w=6-0-1>> 5
w*h>>5*2>> 10>> area

pop>> 0, arr[0]=2>>h
stack>>-1
if stack empty the w=index
w=6>> 6
w*h>> 6*2>> 12>> area>> max




Queue:
	Implementation of Circular Queue via Object Oriented/ LinkedList

	Least Recently Used Cache System















