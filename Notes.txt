Objective of programming:
	Data
	Operations/ functions:
		Create
		Read 
		Update
		Delete


Java Programming:
	Desktop
	Web
	Mobile
	
System Design Engineer
	Low level designer:
		design architecture, algorithms, design patterns, ...


Syntax:
class IDENTIFIER{
	public static void main(String[] identifier){
	.....
	}
}	


Java Development Kit >> Software DK
	build(.java) compile >> source code >> byte code(ASCII+UNI)>> .class
	Java Runtime Environment: in built classes grouped in packages
		Execute
		Java Virtual Machine:
			byte code to machine code
			
Compile: source to bytecode
	javac Filename.java
Execute:	bytecode to machine
	java Classname
	


https://github.com/razzaksr/NGP-Java-DSA-AiDS


Scanner >> java.util
	Scanner obj = new Scanner(System.in); >> object
		nextInt	>> get int input from keyboard
		nextFloat
		nextDouble
		nextShort
		nextLong
		nextBoolean
		nextByte
	String:	
		next		>> word
		nextLine	>> sentence




Class has following members:
	data member>> objects/ variables 				
	member functions/ methods


Object Oriented Programming:
	Build the application with Security, Reusability

	Class
	Encapsulation:
		private data
		public function to access the private data

	Constructor:
		method/ function to be executed while creating an object
		it has priority execution over the other functions
		members initialization
		name of the constructor same as class name
	Polymorphism:
		Overloading: within class same block to be created multiple times by changing parameters type, order, count 
			constructor
			function
		Overriding: between two classes which involved in inheritance, which maintain same name, parameter

	Inheritance: Enables Object reusability between classes
		base/ super/ parent 
		derived / child 

		DerivedClass extends BaseClass

	Abstraction:
		interface like a class block:
			members>> data members, member functions

			class extends class
			class implements interface
			interface extends interface
			interface cannot inherit class


	





task:
employee
1. check which TAX slab
2. check eligibility of PL by check last 3/5 years ITR filed or not

Upcasting & down casting

Sealed and final

Object Cloning:
	1. implements Cloneable
	2. override clone in derived class


Wrapper classes: java.lang
int(4) >> Integer
float(4)>> Float
double(8)>> Double
char(2)>> Character
boolean(1nibble/4bit)>> Boolean
long(8)>> Long
short(2)>> Short
byte(1)>> Byte


task:
	Abstract Class PRODUCTS contains array consists product cost such as 900,4500,200,1600 
	methods:
	1. Non abstract method: findBoundary(min, max) >> Now finding existing costs which matches user given boundary like min and max inside same class
	2. Abstract method: findAll>> print all costs


	interface SHORTLIST contains
	1.Abstract method: findMax()>> Find max cost in that array, consider this method as abstract inside interface

	Inherit All in the class APP 


Specifiers and Modifiers:

			class 			data member			member function

public 		all over project		based on class scope	based on class scope
private		member class		within class			within class
static		member class		calling via classname	calling via classname
final			cannot inherit		constant				cannot override
default		package level		package level			package level
protected		member class		accessible via inheritance
							while out of package
abstract		cannot instantiate	NA					need to override



Exception Handling:
	Error			>> compile time errors: syntax error, Case error	>> can be fixed
				     run time errors: cannot be fixed
	Exception		>> due to uncertain condition the code will be terminated abnormally
					compile time/ checked >> need to handle at compile time in order to 						execute
					usually raised when some of in built method are called/used by 						developers
				     run time/ unchecked	>> raised due to user mistakes

	Objective to handle the exception:
		1. let the user to complete the process even though they make mistake
		2. provide another chance

	Handling:
		1. try{
			.. possible lines which cause exception
		}catch(ExceptionClass obj){
			// handling
		}

		2. throws


		Throwable		>> interface
			|
		Exception			class>> java.lang
			|
		RuntimeException	class>> java.lang
			|
		NullPointerException	class>> java.lang


Type parsing:
	Convert String into Other types via its wrapper class
		WrapperClass.parseType(string)
	eg: converting string into int
		Integer.parseInt(string)
		String hi="78"; String hello="89!"
	NumberFormatException
	

	ExceptionChain
	NestedException
	single try multi catch
	infinite and finite amount of chances
	exception forwarding via throw keyword
	Custom exception creation>> eg: invalid aadhaar when its not equal to the length of 12


Loop:
Nested loop in real time scenario>> ticket booking for multiple busses, giant wheel
Patterns:
	square
	left upper floyd/triangle
	right upper floyd/triangle
	upper pyramid
	sand clock

	Generics:
		class, method, interface, object
		eg: CRUD Operations


Collection framework: java.util
	Iterable	>> interface
	|
	Collections>>
	|
	Collection
	|
	List, Set, Map


List: ArrayList, Vector, LinkedList, Stack
Collections >> sort, replaceAll, reverse
Comparator
	

Queue: PriorityQueue, Deque
Set: HashSet, TreeSet, LinkedHashSet
Map: HashMap, TreeMap, Hashtable



Drawbacks of array:
	No inbuilt methods
	fixed size
	fixed type
	compile time
	not secure