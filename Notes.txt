Objective of programming:
	Data
	Operations/ functions:
		Create
		Read 
		Update
		Delete


Java Programming:
	Desktop
	Web
	Mobile
	
System Design Engineer
	Low level designer:
		design architecture, algorithms, design patterns, ...


Syntax:
class IDENTIFIER{
	public static void main(String[] identifier){
	.....
	}
}	


Java Development Kit >> Software DK
	build(.java) compile >> source code >> byte code(ASCII+UNI)>> .class
	Java Runtime Environment: in built classes grouped in packages
		Execute
		Java Virtual Machine:
			byte code to machine code
			
Compile: source to bytecode
	javac Filename.java
Execute:	bytecode to machine
	java Classname
	


https://github.com/razzaksr/NGP-Java-DSA-AiDS


Scanner >> java.util
	Scanner obj = new Scanner(System.in); >> object
		nextInt	>> get int input from keyboard
		nextFloat
		nextDouble
		nextShort
		nextLong
		nextBoolean
		nextByte
	String:	
		next		>> word
		nextLine	>> sentence




Class has following members:
	data member>> objects/ variables 				
	member functions/ methods


Object Oriented Programming:
	Build the application with Security, Reusability

	Class
	Encapsulation:
		private data
		public function to access the private data

	Constructor:
		method/ function to be executed while creating an object
		it has priority execution over the other functions
		members initialization
		name of the constructor same as class name
	Polymorphism:
		Overloading: within class same block to be created multiple times by changing parameters type, order, count 
			constructor
			function
		Overriding: between two classes which involved in inheritance, which maintain same name, parameter

	Inheritance: Enables Object reusability between classes
		base/ super/ parent 
		derived / child 

		DerivedClass extends BaseClass

	Abstraction:
		interface like a class block:
			members>> data members, member functions

			class extends class
			class implements interface
			interface extends interface
			interface cannot inherit class


	





task:
employee
1. check which TAX slab
2. check eligibility of PL by check last 3/5 years ITR filed or not

Upcasting & down casting

Sealed and final

Object Cloning:
	1. implements Cloneable
	2. override clone in derived class


Wrapper classes: java.lang
int(4) >> Integer
float(4)>> Float
double(8)>> Double
char(2)>> Character
boolean(1nibble/4bit)>> Boolean
long(8)>> Long
short(2)>> Short
byte(1)>> Byte


task:
	Abstract Class PRODUCTS contains array consists product cost such as 900,4500,200,1600 
	methods:
	1. Non abstract method: findBoundary(min, max) >> Now finding existing costs which matches user given boundary like min and max inside same class
	2. Abstract method: findAll>> print all costs


	interface SHORTLIST contains
	1.Abstract method: findMax()>> Find max cost in that array, consider this method as abstract inside interface

	Inherit All in the class APP 


Specifiers and Modifiers:

			class 			data member			member function

public 		all over project		based on class scope	based on class scope
private		member class		within class			within class
static		member class		calling via classname	calling via classname
final			cannot inherit		constant				cannot override
default		package level		package level			package level
protected		member class		accessible via inheritance
							while out of package
abstract		cannot instantiate	NA					need to override



Exception Handling:
	Error			>> compile time errors: syntax error, Case error	>> can be fixed
				     run time errors: cannot be fixed
	Exception		>> due to uncertain condition the code will be terminated abnormally
					compile time/ checked >> need to handle at compile time in order to 						execute
					usually raised when some of in built method are called/used by 						developers
				     run time/ unchecked	>> raised due to user mistakes

	Objective to handle the exception:
		1. let the user to complete the process even though they make mistake
		2. provide another chance

	Handling:
		1. try{
			.. possible lines which cause exception
		}catch(ExceptionClass obj){
			// handling
		}

		2. throws


		Throwable		>> interface
			|
		Exception			class>> java.lang
			|
		RuntimeException	class>> java.lang
			|
		NullPointerException	class>> java.lang


Type parsing:
	Convert String into Other types via its wrapper class
		WrapperClass.parseType(string)
	eg: converting string into int
		Integer.parseInt(string)
		String hi="78"; String hello="89!"
	NumberFormatException
	

	ExceptionChain
	NestedException
	single try multi catch
	infinite and finite amount of chances
	exception forwarding via throw keyword
	Custom exception creation>> eg: invalid aadhaar when its not equal to the length of 12


Loop:
Nested loop in real time scenario>> ticket booking for multiple busses, giant wheel
Patterns:
	square
	left upper floyd/triangle
	right upper floyd/triangle
	upper pyramid
	sand clock

	Generics:
		class, method, interface, object
		eg: CRUD Operations


Collection framework: java.util
	Iterable	>> interface
	|
	Collections>>
	|
	Collection
	|
	List, Set, Map


List: duplicates allowed, positions available
ArrayList, Vector, LinkedList, Stack
Collections >> sort, replaceAll, reverse
Comparator
	
Queue: PriorityQueue, Deque

Set: No duplicates, no position
HashSet
TreeSet 
LinkedHashSet

Comparable

Map: <KeyClass,ValueClass>, where Key Objects must be duplicated, values can be

HashMap, TreeMap, Hashtable





Drawbacks of array:
	No inbuilt methods
	fixed size
	fixed type
	compile time
	not secure





Data structures:
	how can we arrange data in the storage
		eg: lab system were arranged as multi dimensional array
	
Analysis:
Time >> how fast the required action to be done, it s purely based on algorithm
Space >> how much space(variables, constants) required to complete a process

Notations:
	Omega	>> low/ min 
	Theta	>> Average 
	Oho		>> worst/ max 

O(1)		one
O(n)		linear
O(logn)	divide
O(n2)	nested
O(nlogn)	eg: merge, binary search


Task:
Consider the array contains salary of my employees size 10 where you are required to search and display the second high salaried employee's position
eg:
8.9, 4.5, 1.8, 2.5, 4.1, 5.0, 3.5, 2.8, 15.6, 2.1
Output:
0
9.2,8.9,5.2,3.5,1.55, 19.5, 1.8, 7.5, 21.5, 10.5
Output:
5


An array contains invoices of the day, your task is find missing least invoice
eg:
invoices = [45,91,90,92,46]
output:47
invoices = [1,2,3,4,5]
Output: 6
invoices = [12,13,14,16,17]
Output: 15



Merge sort:

Divide and Conquer




Sort Colors (Dutch National Flag)
	Problem Statement:
		Assume that your are part of support team in IRCTC app where customers would raise issue and it will be considered priority ticket such as 0, 1 and 2. now today tickets are in the bucket and you need to arrange it by priority
		Example:
		Input:
		2,0,0,1,0,2,0,1
		Output:
		0,0,0,0,1,1,2,2
		Sample Input:
		nums = [2, 0, 2, 1, 1, 0]
		Expected Output:
		[0, 0, 1, 1, 2, 2]



Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
Constraints:
s consists of parentheses only '()[]{}'.
Example 1:
Input: s = "()"
Output: true
Example 2:
Input: s = "()[]{}"
Output: true
Example 3:
Input: s = "(]"
Output: false
Example 4:
Input: s = "([])"
Output: true
Example 5:
Input: s = "([)]"
Output: false



Given an array of integers nums, for each element in the array, find the Next Greater Element (NGE) to its right.
- The Next Greater Element for an element x is the first element to the right of x that is strictly greater than x.
- If no such element exists, return -1 for that position.
You need to return a list of integers where each index contains the Next Greater Element of the corresponding element in nums.
Example Explanation
For nums = [2, 1, 3]:
- Next greater for 2 → 3
- Next greater for 1 → 3
- Next greater for 3 → -1
Output: [3, 3, -1]
Input1: nums = [4, 5, 2, 25]
Output: [5, 25, 25, -1]
Input: nums = [13, 7, 6, 12]
Output: [-1, 12, 12, -1]




Quick sort:
divide and conquer 
divide by pivotal point :: pivotal data always end of array


Implement Stack structure with its operations using linkedlist(object oriented way)

1. Node (value, address/reference to next node)
2. Service>> stack operations implementations
3. Remote>> stack operations declaration
	push
	pop
	isEmpty
	peek

largest rectangle are in histogram
arr= [2,3,4,5,2,3]
        0 1 2 3 4 5

index=0, cvalue=2
stack>> 0
index=1, cvalue=3
stack>> 0, 1
index=2, cvalue=4
stack>> 0, 1, 2
index=3, cvalue=5
stack>> 0,1,2,3,
index=4, cvalue=2

pop when cvalue < top's value
1. pop>>3, arr[3] >> 5 >> height
stack >> 0, 1, 2
width >> index - 2 - 1 >> 1 
width*height>>5*1>> 5>> area
2. since, cvalue=2 < arr[2]=4,
pop>>2,arr[2] >> 4 >> height
stack>>0,1
width>> 4-1-1>> 2
w*h>>2*4>> 8>> area
3. since cvalue=2 < arr[1]=3
pop>>1, arr[1]>> 3>> h
stack>>0
w>>4-0-1>>3
w*h>>3*3>>9>> area

push index 4 since 2==2
stack>>0,4

index=5, cvalue=3
stack>> 0,4,5

index=6, cvalue=0
pop>>5, arr[5]=3>>h
stack>> 0,4
w= 6-4-1>> 1
w*h>>1*3>> 3>> area

pop>>4, arr[4]=2>>h
stack>> 0
w=6-0-1>> 5
w*h>>5*2>> 10>> area

pop>> 0, arr[0]=2>>h
stack>>-1
if stack empty the w=index
w=6>> 6
w*h>> 6*2>> 12>> area>> max




Queue:
	Implementation of Circular Queue via Object Oriented/ LinkedList

	Least Recently Used Cache System



Non linear structure:
Tree
Binary Tree:
	CRUD, Traversals
	Diameter
	Max Path Sum
Binary Search Tree:
	Insertion
	Level Order Traversal

AVL Tree:
	Self/ height balanced Binary search tree
	eg: folder creation/deletion in any location of computer automatically align based on name(self align)
	balancing done via balance factor:
		balance factor should -1,0,+1
		balance factor = height of left - height of right

	Self balancing done by performing any of following required rotation:
		1. left rotation when right right insertion
		2. right rotation when left left insertion
		3. left right rotation when left right insertion
		4. right left rotation when right left insertion


Segment Tree:
	Range Queries such as sum, min, max


int[] arr={2, 5, 1, 4, 9, 3}
n=6
size, arr[],  sumsTree[n*4]


2 5 1 4 9 3
0 1 2 3 4 5

1=node
s=0, e=5


Fenwick Tree/ Binary Indexed Tee:
 	prefix operations>> prefixSum, prefixMin....

2 5 1 4 9 3		size = 6		0 index based
0 1 2 3 4 5

BIT 	size = 7		1 index based
 0 0 0 0 0 0 0

arr[0] = 2, index=1 in BIT
next possible index to add arr[0]>> 
 0 2 0 0 0 0 0
index + (index & -index)
1 + (1&-1)	= 2  >> add arr[0] in index 2
 0 2 2 0 0 0 0
2 + (2&-2)  = 4 >> add arr[0] in index 4
 0 2 2 0 2 0 0

arr[1] = 5, index=2 in BIT
 0 2 7 0 2 0 0
2+(2&-2)	= 4>> add arr[1] in index 4
 0 2 7 0 7 0 0

arr[2] =1, index = 3 in BIT
add arr[2] in index 3
 0 2 7 1 7 0 0
3+(3&-3) = 4 add arr[2] in index 4
 0 2 7 1 8 0 0

arr[3]=4, index = 4 in BIT
add arr[3] in index 4
 0, 2, 7, 1, 12, 0, 0

arr[4]=9, index = 5 in BIT
add arr[4] in index 5
 0, 2, 7, 1, 12, 9, 0
next>> poss 
5+(5&-5) >> 6, add arr[4] in index 6 of BIT
 0, 2, 7, 1, 12, 9, 9

arr[5]=3, index=6 in BIT
add arr[5] in index 6
 0, 2, 7, 1, 12, 9, 12




Graph:
	Edge;
	Vertex;

types:
	weighted
	unweighted
	direct
	undirect
	cyclic
	acyclic
	

Graph representation:
	adjacency matrix
	adjacency List
	adjacency Map

Implementation of BFS, DFS

Finding Degree

Cyclic detection
	directed and undirected graph

Topological sort/ order:

	cpu scheduling
	shipment scheduling: place, pack, ship, transit, delivery

 applied only on Directed Acyclic Graph DAG

1->2
1->3
3->4


Adjacency Map
1		[2,3]
2		[]
3		[4]
4		[]


In Degrees:
indegree[1] >> 0
indegree[2] >> 1
indegree[3] >> 1
indegree[4] >> 1

PriorityQueue >> stores in degree
queue = [1] , topoOrder  []

poll >> 1	>> topoOrder[1,]
1>>2,3
queue>>[2,3]

pop 2, topoOrder=[1,2]
2>>[]

pop 3 , topoOrder = [1,2,3]
3>>4
queue[4]

pop 4 topoOrder = [1,2,3,4]

topoOrder = [1,2,3,4]


Test case :
1->2
1->3
3->4
2->4
4->5
5->6

adjacency:
1		[2,3]
2		[4]
3		[4]
4		[5]
5		[6]

in degrees:
indegree[1] >> 0
indegree[2] >> 1
indegree[3] >> 1
indegree[4] >> 2
indegree[5] >> 1
indegree[6] >> 1

queue = [1 ], topoOrder = []
poll>> 1, topoOrder = [1]
1>> 2,3, add default '0'
queue=[2,3]

poll 2, topoOrder = [1,2]
2>> 4 add default 0
queue [3,4]

poll 3, topoOrder=1,2,3
3>>4 add deault 0
queue[4]

poll 4, topoOrder = 1,2,3,4
4>>5 add default 0
queue [5]
.
.
.

Shortest Path Algorithms:
	DiJkstra
	Bellman ford
	
Dijkstra:
Adjacency:
	0->1      	9
	0->2     	6
	0->3		5
	0->4		3
	2->1		2
	2->3		4

distance[5]>> 0 to 4
dis=[0,inf,inf,inf,inf]
pq=[(0,0)] >> (vertex,weight)
poll from pq
traverse over neighbor
update distance and offer to pq

vertex=0, distance=0
0 -> 1 >> 9
dist[0]+9 >> 9 
dist[1]> inf
dist[0]+9 < dist[1]
update dist[1] = 9
push (1,9)
dis=[0,9,inf,inf,inf]

nei 0->2  >>  6
0+6 < inf
dist[2] = 6
dis=[0,9,6,inf,inf]
pq push (2,6)


nei 0 -> 3		5
0+5 < inf
dist[3] = 5
push (3,5)

nei 	0->4		3
0+3 < inf
dist[4] = 3
push (4,3)

pq = [ (1,9)(2,6)(3,5)(4,3) ]
pq = [ (4,3)(3,5)(2,6)(1,9) ]
dist=[0,9,6,5,3]



polled (4,3)

polled (3,5)


polled 	2,6
nei 2->1	2
dist[2]+2	>> 6+2>> 8
dist[1]>> 9
8<9	
dist[1] = 8
push (1,8)

nei 2->3		4
dist[2] + 4 < dist[3]
6+4>> 10 < 5
no update 
no push

dist=[0,8,6,5,3]
pq = [ (1,8)(1,9) ]

no neighbors for 1

dist=[0,8,6,5,3]>> final result




Bellman ford:
0->1		-1
0->2		4
1->2		3
1->3		2
1->4		2
3->2		5
3->1		1
4->3		-3

dist=[max,max,max,max,max]
begin=0
dist=[0,max,max,max,max]

index=1  < size  >> 1,2,3,4
key>> 0,1,3,4

if 0 is begin then neighbors
0->1		-1	0 +  -1	-1	dist[1] = -1
0->2		4	0 + 4		4	dist[2]=4
1->2		3	-1 + 3	2	dist[2]=2
1->3		2	-1+2		1	dist[3]=1
1->4		2	-1 + 2	1	dist[4] = 1
3->2		5	1 + 5		6	no update
3->1		1	1 + 1 	2	no update
4->3		-3	1 + (-3)	-2	dist[3]=-2

dist=[0,-1,2,-2,1]
0->1		-1	0+(-1)	-1	no update
0->2		4	0+4		4	no update
1->2 no update
1->3 no update
1->4 no update
3->2		5	-2 + 5	3	







Reconstruct Itinerary
You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.
All of the tickets belong to a man who departs from "SALEM", thus, the itinerary must begin with "SALEM". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
For example, the itinerary ["SALEM", "BLR"] has a smaller lexical order than ["SALEM", "MADURAI"].
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

Input: tickets = [["SALEM","COVAI"],["TRICHY","SALEM"],
["MADUARI","BLR"],["COVAI","MADURAI"]]
Output: [SALEM, COVAI, MADURAI, BLR]
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]


Word Ladder
A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk 
such that:
Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. 
Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.

Example 1:
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.

Example 2:
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: 0
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.


beginWord = "hit"
endWord   = "cog"
wordList  = ["hot","dot","dog","lot","log","cog"]







Swim in Rising Water
You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).
It starts raining, and water gradually rises over time. At time t, the water level is t, meaning any cell with elevation less than equal to t is submerged or reachable.
You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.
Return the minimum time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).

Example 1:
Input: grid = [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.

Example 2:
Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation: The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.




www.hackerrank.com/java-dsa-graph-5
Pacific and Atlantic Water Flow:
5 5
1 2 2 3 5
3 2 3 4 4
2 4 5 3 1
6 7 1 4 5
5 1 1 2 4

0 4
1 3
1 4
2 2
3 0
3 1
4 0






Problem statements:

1. Move Zeroes
Problem Statement:
Rearrange a delivery queue where zeros indicate unavailable trucks; push them to the end without disrupting the rest.

	Sample Input:
	nums = [0, 1, 0, 3, 12]
	Expected Output:
	[1, 3, 12, 0, 0]

	Input:
	20,0,19,5,0,3,10,0,2
	Output:
	20,19,5,3,10,2,0,0,0

	Input:
	3,0,0,1,0,5,0,6,0
	Output:
	3,1,5,6,0,0,0,0,0


Find Pivot Index
Problem Statement:
Determine the index at which the workload to its left equals the workload to its right.
	Sample Input:
	nums = [1, 7, 3, 6, 5, 6]
	Expected Output:	3
	Explanation: 1 + 7 + 3 = 11, 5 + 6 = 11.
	Input:
	-7, 1, 5, 2, -4, 3, 0
	Output:	3
	Input:
	0,-3,5,-4,-2,3,1,0
	Output:	0


Best Time to Buy and Sell Stock
Problem Statement:
Identify the best day to buy and the best day to sell for highest profit from historical stock prices.
Sample Input:
	prices = [7, 1, 5, 3, 6, 4]
	Buy at 1 and sell at 6.

	45, 12, 3, 10, 50
	Best time to buy 3 best time to sell 50

	-10, -5, -2, -1, 1
	Best time to buy -10 best time to sell 1

	90, 40, 20, 10, 4
	Best time to buy 10 best time to sell 4









Longest Consecutive Sequence, Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.
Example 1:
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.

Example 2:
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

Example 3:
Input: nums = [1,0,1,2]
Output: 3




		Group Anagrams
		Problem Statement:
		Cluster search queries or user aliases that are scrambled versions of each other — useful in NLP or 		search optimization.
		Sample Input:
		strs = ["eat","tea","tan","ate","nat","bat"]
		Expected Output:
		[["eat","tea","ate"], ["tan","nat"], ["bat"]]



Minimum Moves to Convert String
You are given a string s consisting of n characters which are either 'X' or 'O'.
A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.
Return the minimum number of moves required so that all the characters of s are converted to 'O'.
		Example 1:
		Input: s = "XXX"
		Output: 1	
		Explanation: XXX -> OOO
		We select all the 3 characters and convert them in one move.
		Example 2:
		Input: s = "XXOX"
		Output: 2
		Explanation: XXOX -> OOOX -> OOOO
We select the first 3 characters in the first move, and convert them to 'O'.
Then we select the last 3 characters and convert them so that the final string contains all 'O's.
		Example 3:
		Input: s = "OOOO"
		Output: 0
Explanation: There are no 'X's in s to convert.



Trapping Rain Water
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water are being trapped.

Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9



		Validating IPV4
		Input: s = "222.111.111.111"
		Output: true
		Explanation: Here, the IPv4 address is as per the criteria mentioned and also 		all four decimal numbers lies in the mentioned range.
		Input: s = "5555..555"
		Output: false
		Explanation: "5555..555" is not a valid. IPv4 address, as the middle two 			portions are missing.
		Input: s = "0.0.0.0255"
		Output: false



Debt Offset Triplets
In financial reconciliation systems or crowdfunding platforms, contributions from individuals may either be positive (contributions) or negative (debts). When evaluating such data, it becomes important to identify sets of contributors whose combined impact on the overall balance nets to zero.
You are given a list of integers nums, where each value represents the contribution or debt of a participant. Your task is to find all unique triplets in the list which sum to zero.
Each triplet must include three distinct elements from the array, and the result must not contain duplicate triplets, regardless of the order. For example, triplets like [-1, 0, 1] and [0, 1, -1] are considered the same and should be reported only once.
This problem simulates scenarios such as offsetting financial imbalances, detecting fraudulent balancing acts, or automated clearing systems identifying neutralizing transactions.
Example 1:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.





Insert Interval
Problem Statement:
Insert a new booking and merge overlapping intervals in an existing schedule.

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].




Jump Game II
You are given a 0-indexed array of integers nums of length n. You are initially positioned at index 0.
Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at index i, you can jump to any index (i + j) where:
0 <= j <= nums[i] and
i + j < n
Return the minimum number of jumps to reach index n - 1. The test cases are generated such that you can reach index n - 1.

Example 1:
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:
Input: nums = [2,3,0,1,4]
Output: 2

Example 3:
Input: nums = [3,2,1,0,4],                  output: -1



Test Case 1: nums = [2,3,1,1,4]
Initial: jumps=0, currentEnd=0,   dist=0
Loop (i from 0 to 3):
- i=0 →   dist = max(0, 0+2)=2  
  - i==currentEnd (0==0) → jumps=1, currentEnd=2  
- i=1 →   dist = max(2, 1+3)=4  
- i=2 →   dist = max(4, 2+1)=4  
  - i==currentEnd (2==2) → jumps=2, currentEnd=4  
- i=3 →   dist = max(4, 3+1)=4  
End:   dist=4 ≥ last index=4 → return jumps=2
Output: 2



Test Case 3: nums = [3,2,1,0,4]
Initial: jumps=0, currentEnd=0,   dist=0
Loop (i from 0 to 3):
- i=0 →   dist = max(0, 0+3)=3  
  - i==currentEnd → jumps=1, currentEnd=3  
- i=1 →   dist = max(3, 1+2)=3  
- i=2 →   dist = max(3, 2+1)=3  
- i=3 →   dist = max(3, 3+0)=3  
  - i==currentEnd (3==3) → jumps=2, currentEnd=3  
  - But check: currentEnd <= i → 3 <= 3 → true → return `-1` (unreachable)
End: returns -1 because we’re stuck at index 3 and cannot move forward to reach index 4.
Output: -1























1. Non-overlapping Intervals, Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
Note that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.

Example 1:
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
Example 2:
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
Example 3:
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.

Constraints:
1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104


2. Hand of Straights, Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.
Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.
Example 1:
Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
Output: true
Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]
Example 2:
Input: hand = [1,2,3,4,5], groupSize = 4
Output: false
Explanation: Alice's hand can not be rearranged into groups of 4.
Example 3:
hand = [1,2,4,5,7,8], groupSze = 3
Output: false
[1,2,4][5,7,8]
Example 4:
hand = [1,1,1,2,3,4], groupSze = 3
Output: false
[1,2,3][1,1,4]

Constraints:
1 <= hand.length <= 104
0 <= hand[i] <= 109
1 <= groupSize <= hand.length