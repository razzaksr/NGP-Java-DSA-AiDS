Objective of programming:
	Data
	Operations/ functions:
		Create
		Read 
		Update
		Delete


Java Programming:
	Desktop
	Web
	Mobile
	
System Design Engineer
	Low level designer:
		design architecture, algorithms, design patterns, ...


Syntax:
class IDENTIFIER{
	public static void main(String[] identifier){
	.....
	}
}	


Java Development Kit >> Software DK
	build(.java) compile >> source code >> byte code(ASCII+UNI)>> .class
	Java Runtime Environment: in built classes grouped in packages
		Execute
		Java Virtual Machine:
			byte code to machine code
			
Compile: source to bytecode
	javac Filename.java
Execute:	bytecode to machine
	java Classname
	


https://github.com/razzaksr/NGP-Java-DSA-AiDS


Scanner >> java.util
	Scanner obj = new Scanner(System.in); >> object
		nextInt	>> get int input from keyboard
		nextFloat
		nextDouble
		nextShort
		nextLong
		nextBoolean
		nextByte
	String:	
		next		>> word
		nextLine	>> sentence




Class has following members:
	data member>> objects/ variables 				
	member functions/ methods


Object Oriented Programming:
	Build the application with Security, Reusability

	Class
	Encapsulation:
		private data
		public function to access the private data

	Constructor:
		method/ function to be executed while creating an object
		it has priority execution over the other functions
		members initialization
		name of the constructor same as class name
	Polymorphism:
		Overloading: within class same block to be created multiple times by changing parameters type, order, count 
			constructor
			function
		Overriding: between two classes which involved in inheritance, which maintain same name, parameter

	Inheritance: Enables Object reusability between classes
		base/ super/ parent 
		derived / child 

		DerivedClass extends BaseClass

	Abstraction:
		interface like a class block:
			members>> data members, member functions

			class extends class
			class implements interface
			interface extends interface
			interface cannot inherit class


	





task:
employee
1. check which TAX slab
2. check eligibility of PL by check last 3/5 years ITR filed or not

Upcasting & down casting

Sealed and final

Object Cloning:
	1. implements Cloneable
	2. override clone in derived class


Wrapper classes: java.lang
int(4) >> Integer
float(4)>> Float
double(8)>> Double
char(2)>> Character
boolean(1nibble/4bit)>> Boolean
long(8)>> Long
short(2)>> Short
byte(1)>> Byte


task:
	Abstract Class PRODUCTS contains array consists product cost such as 900,4500,200,1600 
	methods:
	1. Non abstract method: findBoundary(min, max) >> Now finding existing costs which matches user given boundary like min and max inside same class
	2. Abstract method: findAll>> print all costs


	interface SHORTLIST contains
	1.Abstract method: findMax()>> Find max cost in that array, consider this method as abstract inside interface

	Inherit All in the class APP 


Specifiers and Modifiers:

			class 			data member			member function

public 		all over project		based on class scope	based on class scope
private		member class		within class			within class
static		member class		calling via classname	calling via classname
final			cannot inherit		constant				cannot override
default		package level		package level			package level
protected		member class		accessible via inheritance
							while out of package
abstract		cannot instantiate	NA					need to override



Exception Handling:
	Error			>> compile time errors: syntax error, Case error	>> can be fixed
				     run time errors: cannot be fixed
	Exception		>> due to uncertain condition the code will be terminated abnormally
					compile time/ checked >> need to handle at compile time in order to 						execute
					usually raised when some of in built method are called/used by 						developers
				     run time/ unchecked	>> raised due to user mistakes

	Objective to handle the exception:
		1. let the user to complete the process even though they make mistake
		2. provide another chance

	Handling:
		1. try{
			.. possible lines which cause exception
		}catch(ExceptionClass obj){
			// handling
		}

		2. throws


		Throwable		>> interface
			|
		Exception			class>> java.lang
			|
		RuntimeException	class>> java.lang
			|
		NullPointerException	class>> java.lang


Type parsing:
	Convert String into Other types via its wrapper class
		WrapperClass.parseType(string)
	eg: converting string into int
		Integer.parseInt(string)
		String hi="78"; String hello="89!"
	NumberFormatException
	

	ExceptionChain
	NestedException
	single try multi catch
	infinite and finite amount of chances
	exception forwarding via throw keyword
	Custom exception creation>> eg: invalid aadhaar when its not equal to the length of 12


Loop:
Nested loop in real time scenario>> ticket booking for multiple busses, giant wheel
Patterns:
	square
	left upper floyd/triangle
	right upper floyd/triangle
	upper pyramid
	sand clock

	Generics:
		class, method, interface, object
		eg: CRUD Operations


Collection framework: java.util
	Iterable	>> interface
	|
	Collections>>
	|
	Collection
	|
	List, Set, Map


List: duplicates allowed, positions available
ArrayList, Vector, LinkedList, Stack
Collections >> sort, replaceAll, reverse
Comparator
	
Queue: PriorityQueue, Deque

Set: No duplicates, no position
HashSet
TreeSet 
LinkedHashSet

Comparable

Map: <KeyClass,ValueClass>, where Key Objects must be duplicated, values can be

HashMap, TreeMap, Hashtable





Drawbacks of array:
	No inbuilt methods
	fixed size
	fixed type
	compile time
	not secure





Data structures:
	how can we arrange data in the storage
		eg: lab system were arranged as multi dimensional array
	
Analysis:
Time >> how fast the required action to be done, it s purely based on algorithm
Space >> how much space(variables, constants) required to complete a process

Notations:
	Omega	>> low/ min 
	Theta	>> Average 
	Oho		>> worst/ max 

O(1)		one
O(n)		linear
O(logn)	divide
O(n2)	nested
O(nlogn)	eg: merge, binary search


Task:
Consider the array contains salary of my employees size 10 where you are required to search and display the second high salaried employee's position
eg:
8.9, 4.5, 1.8, 2.5, 4.1, 5.0, 3.5, 2.8, 15.6, 2.1
Output:
0
9.2,8.9,5.2,3.5,1.55, 19.5, 1.8, 7.5, 21.5, 10.5
Output:
5


An array contains invoices of the day, your task is find missing least invoice
eg:
invoices = [45,91,90,92,46]
output:47
invoices = [1,2,3,4,5]
Output: 6
invoices = [12,13,14,16,17]
Output: 15



Merge sort:

Divide and Conquer




Sort Colors (Dutch National Flag)
	Problem Statement:
		Assume that your are part of support team in IRCTC app where customers would raise issue and it will be considered priority ticket such as 0, 1 and 2. now today tickets are in the bucket and you need to arrange it by priority
		Example:
		Input:
		2,0,0,1,0,2,0,1
		Output:
		0,0,0,0,1,1,2,2
		Sample Input:
		nums = [2, 0, 2, 1, 1, 0]
		Expected Output:
		[0, 0, 1, 1, 2, 2]



Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
Constraints:
s consists of parentheses only '()[]{}'.
Example 1:
Input: s = "()"
Output: true
Example 2:
Input: s = "()[]{}"
Output: true
Example 3:
Input: s = "(]"
Output: false
Example 4:
Input: s = "([])"
Output: true
Example 5:
Input: s = "([)]"
Output: false



Given an array of integers nums, for each element in the array, find the Next Greater Element (NGE) to its right.
- The Next Greater Element for an element x is the first element to the right of x that is strictly greater than x.
- If no such element exists, return -1 for that position.
You need to return a list of integers where each index contains the Next Greater Element of the corresponding element in nums.
Example Explanation
For nums = [2, 1, 3]:
- Next greater for 2 → 3
- Next greater for 1 → 3
- Next greater for 3 → -1
Output: [3, 3, -1]
Input1: nums = [4, 5, 2, 25]
Output: [5, 25, 25, -1]
Input: nums = [13, 7, 6, 12]
Output: [-1, 12, 12, -1]




Quick sort:
divide and conquer 
divide by pivotal point :: pivotal data always end of array


Implement Stack structure with its operations using linkedlist(object oriented way)

1. Node (value, address/reference to next node)
2. Service>> stack operations implementations
3. Remote>> stack operations declaration
	push
	pop
	isEmpty
	peek

largest rectangle are in histogram
arr= [2,3,4,5,2,3]
        0 1 2 3 4 5

index=0, cvalue=2
stack>> 0
index=1, cvalue=3
stack>> 0, 1
index=2, cvalue=4
stack>> 0, 1, 2
index=3, cvalue=5
stack>> 0,1,2,3,
index=4, cvalue=2

pop when cvalue < top's value
1. pop>>3, arr[3] >> 5 >> height
stack >> 0, 1, 2
width >> index - 2 - 1 >> 1 
width*height>>5*1>> 5>> area
2. since, cvalue=2 < arr[2]=4,
pop>>2,arr[2] >> 4 >> height
stack>>0,1
width>> 4-1-1>> 2
w*h>>2*4>> 8>> area
3. since cvalue=2 < arr[1]=3
pop>>1, arr[1]>> 3>> h
stack>>0
w>>4-0-1>>3
w*h>>3*3>>9>> area

push index 4 since 2==2
stack>>0,4

index=5, cvalue=3
stack>> 0,4,5

index=6, cvalue=0
pop>>5, arr[5]=3>>h
stack>> 0,4
w= 6-4-1>> 1
w*h>>1*3>> 3>> area

pop>>4, arr[4]=2>>h
stack>> 0
w=6-0-1>> 5
w*h>>5*2>> 10>> area

pop>> 0, arr[0]=2>>h
stack>>-1
if stack empty the w=index
w=6>> 6
w*h>> 6*2>> 12>> area>> max




Queue:
	Implementation of Circular Queue via Object Oriented/ LinkedList

	Least Recently Used Cache System



Non linear structure:
Tree
Binary Tree:
	CRUD, Traversals
	Diameter
	Max Path Sum
Binary Search Tree:
	Insertion
	Level Order Traversal

AVL Tree:
	Self/ height balanced Binary search tree
	eg: folder creation/deletion in any location of computer automatically align based on name(self align)
	balancing done via balance factor:
		balance factor should -1,0,+1
		balance factor = height of left - height of right

	Self balancing done by performing any of following required rotation:
		1. left rotation when right right insertion
		2. right rotation when left left insertion
		3. left right rotation when left right insertion
		4. right left rotation when right left insertion


Segment Tree:
	Range Queries such as sum, min, max


int[] arr={2, 5, 1, 4, 9, 3}
n=6
size, arr[],  sumsTree[n*4]


2 5 1 4 9 3
0 1 2 3 4 5

1=node
s=0, e=5


Fenwick Tree/ Binary Indexed Tee:
 	prefix operations>> prefixSum, prefixMin....

2 5 1 4 9 3		size = 6		0 index based
0 1 2 3 4 5

BIT 	size = 7		1 index based
 0 0 0 0 0 0 0

arr[0] = 2, index=1 in BIT
next possible index to add arr[0]>> 
 0 2 0 0 0 0 0
index + (index & -index)
1 + (1&-1)	= 2  >> add arr[0] in index 2
 0 2 2 0 0 0 0
2 + (2&-2)  = 4 >> add arr[0] in index 4
 0 2 2 0 2 0 0

arr[1] = 5, index=2 in BIT
 0 2 7 0 2 0 0
2+(2&-2)	= 4>> add arr[1] in index 4
 0 2 7 0 7 0 0

arr[2] =1, index = 3 in BIT
add arr[2] in index 3
 0 2 7 1 7 0 0
3+(3&-3) = 4 add arr[2] in index 4
 0 2 7 1 8 0 0

arr[3]=4, index = 4 in BIT
add arr[3] in index 4
 0, 2, 7, 1, 12, 0, 0

arr[4]=9, index = 5 in BIT
add arr[4] in index 5
 0, 2, 7, 1, 12, 9, 0
next>> poss 
5+(5&-5) >> 6, add arr[4] in index 6 of BIT
 0, 2, 7, 1, 12, 9, 9

arr[5]=3, index=6 in BIT
add arr[5] in index 6
 0, 2, 7, 1, 12, 9, 12




Graph:
	Edge;
	Vertex;

types:
	weighted
	unweighted
	direct
	undirect
	cyclic
	acyclic
	

Graph representation:
	adjacency matrix
	adjacency List
	adjacency Map

Implementation of BFS, DFS

Finding Degree

Cyclic detection
	directed and undirected graph

Topological sort/ order:

	cpu scheduling
	shipment scheduling: place, pack, ship, transit, delivery

 applied only on Directed Acyclic Graph DAG

1->2
1->3
3->4


Adjacency Map
1		[2,3]
2		[]
3		[4]
4		[]


In Degrees:
indegree[1] >> 0
indegree[2] >> 1
indegree[3] >> 1
indegree[4] >> 1

PriorityQueue >> stores in degree
queue = [1] , topoOrder  []

poll >> 1	>> topoOrder[1,]
1>>2,3
queue>>[2,3]

pop 2, topoOrder=[1,2]
2>>[]

pop 3 , topoOrder = [1,2,3]
3>>4
queue[4]

pop 4 topoOrder = [1,2,3,4]

topoOrder = [1,2,3,4]


Test case :
1->2
1->3
3->4
2->4
4->5
5->6

adjacency:
1		[2,3]
2		[4]
3		[4]
4		[5]
5		[6]

in degrees:
indegree[1] >> 0
indegree[2] >> 1
indegree[3] >> 1
indegree[4] >> 2
indegree[5] >> 1
indegree[6] >> 1

queue = [1 ], topoOrder = []
poll>> 1, topoOrder = [1]
1>> 2,3, add default '0'
queue=[2,3]

poll 2, topoOrder = [1,2]
2>> 4 add default 0
queue [3,4]

poll 3, topoOrder=1,2,3
3>>4 add deault 0
queue[4]

poll 4, topoOrder = 1,2,3,4
4>>5 add default 0
queue [5]
.
.
.

Shortest Path Algorithms:
	DiJkstra
	Bellman ford
	
Dijkstra:
Adjacency:
	0->1      	9
	0->2     	6
	0->3		5
	0->4		3
	2->1		2
	2->3		4

distance[5]>> 0 to 4
dis=[0,inf,inf,inf,inf]
pq=[(0,0)] >> (vertex,weight)
poll from pq
traverse over neighbor
update distance and offer to pq

vertex=0, distance=0
0 -> 1 >> 9
dist[0]+9 >> 9 
dist[1]> inf
dist[0]+9 < dist[1]
update dist[1] = 9
push (1,9)
dis=[0,9,inf,inf,inf]

nei 0->2  >>  6
0+6 < inf
dist[2] = 6
dis=[0,9,6,inf,inf]
pq push (2,6)


nei 0 -> 3		5
0+5 < inf
dist[3] = 5
push (3,5)

nei 	0->4		3
0+3 < inf
dist[4] = 3
push (4,3)

pq = [ (1,9)(2,6)(3,5)(4,3) ]
pq = [ (4,3)(3,5)(2,6)(1,9) ]
dist=[0,9,6,5,3]



polled (4,3)

polled (3,5)


polled 	2,6
nei 2->1	2
dist[2]+2	>> 6+2>> 8
dist[1]>> 9
8<9	
dist[1] = 8
push (1,8)

nei 2->3		4
dist[2] + 4 < dist[3]
6+4>> 10 < 5
no update 
no push

dist=[0,8,6,5,3]
pq = [ (1,8)(1,9) ]

no neighbors for 1

dist=[0,8,6,5,3]>> final result




Bellman ford:
0->1		-1
0->2		4
1->2		3
1->3		2
1->4		2
3->2		5
3->1		1
4->3		-3

dist=[max,max,max,max,max]
begin=0
dist=[0,max,max,max,max]

index=1  < size  >> 1,2,3,4
key>> 0,1,3,4

if 0 is begin then neighbors
0->1		-1	0 +  -1	-1	dist[1] = -1
0->2		4	0 + 4		4	dist[2]=4
1->2		3	-1 + 3	2	dist[2]=2
1->3		2	-1+2		1	dist[3]=1
1->4		2	-1 + 2	1	dist[4] = 1
3->2		5	1 + 5		6	no update
3->1		1	1 + 1 	2	no update
4->3		-3	1 + (-3)	-2	dist[3]=-2

dist=[0,-1,2,-2,1]
0->1		-1	0+(-1)	-1	no update
0->2		4	0+4		4	no update
1->2 no update
1->3 no update
1->4 no update
3->2		5	-2 + 5	3	







Reconstruct Itinerary
You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.
All of the tickets belong to a man who departs from "SALEM", thus, the itinerary must begin with "SALEM". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
For example, the itinerary ["SALEM", "BLR"] has a smaller lexical order than ["SALEM", "MADURAI"].
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

Input: tickets = [["SALEM","COVAI"],["TRICHY","SALEM"],
["MADUARI","BLR"],["COVAI","MADURAI"]]
Output: [SALEM, COVAI, MADURAI, BLR]
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]


Word Ladder
A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk 
such that:
Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. 
Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.

Example 1:
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.

Example 2:
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: 0
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.


beginWord = "hit"
endWord   = "cog"
wordList  = ["hot","dot","dog","lot","log","cog"]







Swim in Rising Water
You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).
It starts raining, and water gradually rises over time. At time t, the water level is t, meaning any cell with elevation less than equal to t is submerged or reachable.
You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.
Return the minimum time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).

Example 1:
Input: grid = [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.

Example 2:
Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation: The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.





















